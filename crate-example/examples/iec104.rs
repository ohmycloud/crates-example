use bitfields::bitfield;

// 命令限定词（QOC）
// QOC := CP6 {QU, S/E}
// QU := UI5 [3...7] <0...31>
//   <0> := 无另外的定义
//   <1> := 短脉冲持续时间（断路器），持续时间由被控站内的系统参数所确定
//   <2> := 长脉冲持续时间，持续时间由被控站内的系统参数所确定
//   <3> := 持续输出
//   <4...8> := 为本配套标准的标准定义保留（兼容范围）
//   <9...15> := 为其他预先定义的功能选集保留
//   <16...31> := 为特定使用保留（专用范围）
// S/E := BSI [8] <0，1>
//   <0> := 执行
//   <1> := 选择
struct QOC {
    qu: u8,
    se: bool,
}

impl QOC {
    const fn from_bits(bits: u8) -> Self {
        Self {
            qu: (bits & 0b01111100) >> 2, // Extract bits 3-7(5 bits)
            se: (bits & 0b10000000) != 0, // Extract the 8th bit(most significant bit)
        }
    }

    // Convert the custom type into bytes
    const fn into_bits(self) -> u8 {
        (self.qu << 2) | ((self.se as u8) << 7)
    }
}

// 设定命令限定词
// QOS := CP8 {QL，S/E}
//   QL := UI7 [1...7] <0...127>
//     <0> := 缺省
//     <1...63> := 为本配套标准的标准定义保留（兼容范围）
//     <64...127> := 为特定使用保留（专用范围）
//   S/E := BS1 [8] <0，1>
//     <0> := 执行
//     <1> := 选择

#[bitfield(u8)]
struct QOS {
    #[bits(7)]
    ql: u8,
    se: bool,
}

#[bitfield(u8)]
struct SCO {
    scs: bool,
    #[bits(1)]
    res: u8,
    #[bits(6)]
    qoc: QOC,
}

#[bitfield(u8)]
struct DCO {
    #[bits(2)]
    dcs: u8,
    #[bits(6)]
    qoc: QOC,
}

// 带品质描述词的单点信息
// SIQ : = CP8 {SPI, RES, BL, SB, NT, IV}

// SPI = 单点信息 := BS1 [1] <0, 1>
//   <0> := 开
//   <1> := 合
// RES=RESERVE := BS3 [2...4] <0>
// BL := BS1 [5] <0, 1>
//   <0> := 未被闭锁
//   <1> := 被闭锁
// SB := BS1 [6] <0, 1>
//   <0> := 未被取代
//   <1> := 被取代
// NT := BS1 [7] <0, 1>
//   <0> := 当前值
//   <1> := 非当前值
// IV := BS1 [8] <0, 1>
//   <0> := 有效
//   <1> := 无效
#[bitfield(u8)]
struct SIQ {
    spi: bool,
    #[bits(3)]
    res: u8,
    bl: bool,
    sb: bool,
    nt: bool,
    iv: bool,
}

// 带品质描述词的双点信息
// DIQ := CP8 {DPI, RES, BL, SB, NT, IV}
// DPI = 双点信息 := UI2[1...2] <0...3>
//    <0> := 不确定或中间状态
//    <1> := 确定状态开
//    <2> := 确定状态合
//    <3> := 不确定
// RES = RESERVE := BS2[3...4] <0>
// BL := BS1 [5] <0, 1>
//    <0> := 未被闭锁
//    <1> := 被闭锁
// SB := BS1 [6] <0, 1>
//    <0> := 未被取代
//    <1> := 被取代
// NT := BS1 [7] <0, 1>
//    <0> := 当前值
//    <1> := 非当前值
// IV := BS1 [8] <0, 1>
//    <0> := 有效
//    <1> := 无效
#[bitfield(u8)]
struct DIQ {
    #[bits(2)]
    dpi: u8,
    #[bits(2)]
    res: u8,
    bl: bool,
    sb: bool,
    nt: bool,
    iv: bool,
}

// 品质描述词
// QDS := CP8 {OV, RES, BL, SB, NT, IV}
// OV := BS1 [1] <0, 1>
//    <0> := 未溢出
//    <1> := 溢出
// RES=RESERVE := BS3 [2...4] <0>
// BL := BS1 [5] <0, 1>
//    <0> := 未被闭锁
//    <1> := 被闭锁
// SB := BS1 [6] <0, 1>
//    <0> := 未被取代
//    <1> := 被取代
// NT := BS1 [7] <0, 1>
//    <0> := 当前值
//    <1> := 非当前值
// IV := BS1 [8] <0, 1>
//    <0> := 有效
//    <1> := 无效
#[bitfield(u8)]
struct QDS {
    ov: bool,
    #[bits(3)]
    res: u8,
    bl: bool,
    sb: bool,
    nt: bool,
    iv: bool,
}

// 继电保护设备事件的品质描述词
// QDP := CP8 {RES, EI, BL, SB, NT, IV}
// RES = RESERVE := BS3 [1...3] <0>
// EI := BS1 [4] <0, 1>
//    <0> := 动作时间有效
//    <1> := 动作时间无效
// BL := BS1 [5] <0,1>
//    <0> := 未被闭锁
//    <1> := 被闭锁
// SB := BS1 [6] <0,1>
//    <0> := 未被取代
//    <1> := 被取代
// NT := BS1 [7] <0,1>
//    <0> := 当前值
//    <1> := 非当前值
// IV := BS1 [8] <0,1>
//    <0> := 有效
//    <1> := 无效
#[bitfield(u8)]
struct QDP {
    #[bits(3)]
    res: u8,
    ei: bool,
    bl: bool,
    sb: bool,
    nt: bool,
    iv: bool,
}

// 继电保护设备单个事件
// SEP := CP8 {ES, RES, EI, BL, SB, NT, IV}
// ES = 事件状态 := UI2 [1, 2] <0...3>
//    <0> := 不确定或中间状态
//    <1> := 确定状态开
//    <2> := 确定状态合
//    <3> := 不确定
// RES = RESERVE := BS1 [3] <0>
// EI := BS1 [4] <0, 1>
//    <0> := 动作时间有效
//    <1> := 动作时间无效
// BL := BS1 [5] <0, 1>
//    <0> := 未被闭锁
//    <1> := 被闭锁
// SB := BS1 [6] <0, 1>
//    <0> := 未被取代
//    <1> := 被取代
// NT := BS1 [7] <0, 1>
//    <0> := 当前值
//    <1> := 非当前值
// IV := BS1 [8] <0, 1>
//    <0> := 有效
//    <1> := 无效
#[bitfield(u8)]
struct SEP {
    #[bits(2)]
    es: u8,
    res: bool,
    ei: bool,
    bl: bool,
    sb: bool,
    nt: bool,
    iv: bool,
}

// 继电保护设备启动事件
// SPE := BS8 {GS, SL1, SL2, SL3, SIE, SRD, RES}
// GS = 总启动 := BS1 [1] <0, 1>
//    <0> := 无总启动
//    <1> := 总启动
// SL1 = A 相保护启动 := BS1 [2] <0, 1>
//    <0> := A 相保护未启动
//    <1> := A 相保护启动
// SL2 = B 相保护启动 := BS1 [3] <0, 1>
//    <0> := B 相保护未启动
//    <1> := B 相保护启动
// SL3 = C 相保护启动 := BS1 [4] <0, 1>
//    <0> := C 相保护未启动
//    <1> := C 相保护启动
// SIE = 接地电流保护启动 := BS1 [5] <0, 1>
//    <0> := 接地电流保护未启动
//    <1> := 接地电流保护启动
// SRD = 反向保护启动 := BS1 [6] <0, 1>
//    <0> := 反向保护未启动
//    <1> := 反向保护启动
// RES = RESERVE := BS2 [7, 8] <0>
#[bitfield(u8)]
struct SPE {
    gs: bool,
    sl1: bool,
    sl2: bool,
    sl3: bool,
    sie: bool,
    srd: bool,
    #[bits(2)]
    res: u8,
}

// 继电器保护设备输出电路信息
// OCI := BS8 {GC, CL1, CL2, CL3, RES}
// GC = 总命令输出至输出电路 := BS1 [1] <0, 1>
//    <0> := 无总命令输出至输出电路
//    <1> := 总命令输出至输出电路
// CL1 = A 相保护命令输出至输出电路 := BS1 [2] <0, 1>
//    <0> := 无命令输出至 A 相输出电路
//    <1> := 命令输出至 A 相输出电路
// CL2 = B 相保护命令输出至输出电路 := BS1 [3] <0, 1>
//    <0> := 无命令输出至 B 相输出电路
//    <1> := 命令输出至 B 相输出电路
// CL3 = C 相保护命令输出至输出电路 := BS1 [4] <0, 1>
//    <0> := 无命令输出至 C 相输出电路
//    <1> := 命令输出至 C 相输出电路
// RES = RESERVE := BS4 [5...8] <0>
#[bitfield(u8)]
struct OCI {
    gc: bool,
    cl1: bool,
    cl2: bool,
    cl3: bool,
    #[bits(4)]
    res: u8,
}

// 步调节命令
// RCO = 步调节命令 := CP8 {RCS, QOC}
// RCS = 步调节命令状态 := UI2 [1, 2] <0...3>
//    <0> := 不允许
//    <1> := 降一步
//    <2> := 升一步
//    <3> := 不允许
// QOC := CP6 [3...8] {QU, S/E}
#[bitfield(u8)]
struct RCO {
    #[bits(2)]
    rcs: u8,
    #[bits(6)]
    qoc: QOC,
}

// 计数量召唤命令限定词
// QCC := CP8 {RQT, FRZ}
// RQT = 请求 := UI6 [1...6] <0...63>
//    <0> := 没请求计数量(未采用)
//    <1> := 请求计数量第 1 组
//    <2> := 请求计数量第 2 组
//    <3> := 请求计数量第 3 组
//    <4> := 请求计数量第 4 组
//    <5> := 总的请求计数量
//    <6...31> := 为本配套标准的标准定义保留（兼容范围）
//    <32...63> :=为特定使用保留（专用范围）
// FRZ = 冻结 := UI2 [7, 8] <0...3>
//    <0> := 读（无冻结或复位）
//    <1> := 计数量冻结不带复位（被冻结的值为累加值）
//    <2> := 计数量冻结带复位（被冻结的值为增量信息）
//    <3> := 计数量复位
#[bitfield(u8)]
struct QCC {
    #[bits(6)]
    rqt: u8,
    #[bits(2)]
    frz: u8,
}

// 测量值参数限定词
// QPM := CP8 {KPA, LPC, POP}
// KPA = 参数类别 := UI6 [1...6] <0...63>
//    <0> := 未用
//    <1> := 门限值
//    <2> := 平滑系数（滤波）
//    <3> := 传送测量值的下限
//    <4> := 传送测量值的上限
//    <5...31> := 为本配套标准的标准定义保留（兼容范围）
//    <32...63> := 为特定使用保留（专用范围）
// LPC = 当地参数改变 := BS1 [7] <0, 1>
//    <0> := 未改变
//    <1> := 改变
// POP = 参数在运行 := BS1 [8] <0, 1>
//    <0> := 运行
//    <1> := 未运行
#[bitfield(u8)]
struct QPM {
    #[bits(6)]
    kpa: u8,
    lpc: bool,
    pop: bool,
}

// 文件的状态
// SOF := CP8 {STATUS, LFD, FOR, FA}
// STATUS := UI5 [1...5] <0...31>
//    <0> := 缺省
//    <1...15> := 为本配套标准的标准定义保留（兼容范围）
//    <16...31> :=为特定使用保留（专用范围）
// LFD := BS1 [6] <0, 1>
//    <0> := 后面还有目录文件
//    <1> := 最后目录文件
// FOR := BS1 [7] <0, 1>
//    <0> := 定义文件名
//    <1> := 定义子目录名
// FA := BS1 [8] <0, 1>
//    <0> := 文件传输等待
//    <1> := 文件传输已激活
#[bitfield(u8)]
struct SOF {
    #[bits(5)]
    status: u8,
    lfd: bool,
    fr: bool,
    fa: bool,
}

// 传送原因 := CP16 {Cause, P/N, T, 源发站地址(任选)}
// Cause := UI6 [1...6] <0...63>
//    <0> := 未定义
//    <1...47> := 传送原因序号
//    <48...63> := 专用范围
// P/N := BS1 [7] <0...1>
//    <0> := 肯定确认
//    <1> := 否定确认
// T = test := BS1 [8] <0...1>
//    <0> := 未实验
//    <1> := 实验
// 源发站地址 := UI8 [9...16] <0...255>
//    <0> := 缺省值
//    <1...255> := 源发站地址号
#[bitfield(u16)]
struct COT {
    #[bits(6)]
    cause: u8,
    pn: bool,
    t: bool,
    #[bits(8)]
    origin_addr: u8,
}

// 选择和召唤限定词
// SCQ := CP8 {UI4 [1...4], UI4 [5...8]}
// UI4 [1...4] <0...15>
//    <0> := 缺省
//    <1> := 选择文件
//    <2> := 请求文件
//    <3> := 停止
//    <4> := 删除文件
//    <5> := 选择节
//    <6> := 请求节
//    <7> := 停止激活节
//    <8...10> :=为本配套标准的标准定义保留（兼容范围）
//    <11...15> :=为特定使用保留（专用范围）
// UI4 [5...8] <0...15>
//    <0> := 缺省
//    <1> := 无所请求的存储空间
//    <2> := 校验和错
//    <3> := 非所期望的通信服务
//    <4> := 非所期望的文件名称
//    <5> := 非所期望的节名称
//    <6...10> := 为本配套标准的标准定义保留（兼容范围）
//    <11...15> := 为特定使用保留（专用范围）
#[bitfield(u8)]
struct SCQ {
    #[bits(4)]
    op: u8,
    #[bits(4)]
    status: u8,
}

fn main() {
    let qoc = QOC { qu: 12, se: false };

    let sco = SCOBuilder::new()
        .with_scs(true)
        .with_res(0)
        .with_qoc(qoc)
        .build();

    println!("{:#?}", sco);
}
